---
title: 正则表达式 - 贪性与惰性
date: 2017-06-03 09:57:39
categories:
    - 正则表达式
tags:
    - 正则表达式
---

使用正则表达式中的 `贪性`、`惰性`、`支配性` 的量词可以控制表达式匹配过程，我们知道量词 `？`、`*`、`+` 的意义，可以指定相关模式出现的次数，默认的情况下我们使用的量词均是是贪婪量词，它的匹配过程是从整个字符串开始查看，如果不匹配就去掉最后一个，再看看是否匹配，如此循环一直到匹配或字符串空为止。不管是 `贪性` 还是 `惰性` ，在正则表达式在匹配失败时都会触发 `正则表达式回溯`（详情查看[正则表达式 - 回溯](/2017/06/03/正则表达式-回溯/)），从而影响其性能。

<!-- more -->

## 量词（Quantifier）

首先，我们需要了解一下正则表达式的量词，正则表达式中有如下几种量词 `?`、`+`、`*`、`{n}`、`{n,m}`、`{n,}`。

| 量词 |  匹配规则  |  例子  |  结果  | 
|:----:|:----:|:----:|:----:|:----:|
| ?   | 匹配出现 0 次或 1 次 | /a?/.test('abcd'); | true |
| +   | 匹配出现 1 次或多次 | /a+/.test('aaaaaaaa'); | true |
| *   | 匹配出现 0 次或 1 次或多次 |  /a*/.test('bbbbb'); | true |
| {n} | 匹配刚好出现 n 次 |  /a{5}/.test('aaaab'); | false |
| {n,m}   | 匹配最少出现 n 次最多出现 m 次 | a{1,3}/.test('aaabbb'); | true |
| {n,}    | 匹配最少出现 n 次 |  /a{3,}/.test('aabbb'); | false |

## 贪性匹配（greediness）

从字面意思我们就可以知道，所谓的"贪婪"的意思就是，如果符合要求就一直往后匹配，一直到无法匹配为止，这就是贪性匹配。默认情况下，`?`、`+`、`*`、`{n}`、`{n,m}`、`{n,}`都是贪婪的，也就是说，它会根据前导字符去匹配尽可能多的内容。

> 贪性匹配就是匹配尽可能 `多` 的内容。

假如我们有一个字符串 `This is a <EM>first</EM> test`，我们使用 `/<.+>/g` 来匹配，我们期望匹配到两段文本，第一段为 `<EM>`，第二段匹配文本为 `</EM>`，但是只得到了一段匹配文本：`<EM>first</EM>`，很显然结果不尽人意，并不是我们想要的。

出现这种情况的罪魁祸首就是 `+` 是 `贪性匹配（greedy）` 的，正则表达式引擎执行 `+` 量词时尽可能的重复匹配前面的符号 `.`  `回溯`（即：正则表达式放弃上一次匹配，吐出一个匹配的字符给剩下的字符串），再一次使用下一个正则表达式符号来匹配剩下的字符串，如此反复 `回溯` 直到匹配成功或回溯到 0。通过下面的例子，可以更加直观的解释他的过程。

`<.+>` 匹配字符串 `This is a <EM>first</EM> test` 的过程：

1. 第一个符号为 `<`，所以它将会匹配到字符串中的第一个 `<` 字符。
2. 第二个符号为 `.`，匹配任意字符（除了换行），使用 `+` 重复匹配，所以它将会不断重复匹配，直到他匹配到句尾，则匹配失败，`.+` 匹配了 `EM>first</EM> test`。
3. 到目前为止 `<.+` 匹配的字符串为：`<EM>first</EM> test`。
4. 正则表达式引擎开始对下一个正则表达式符号 `>` 进行匹配，但字符串还未匹配的只剩下换行符了，于是匹配失败。
5. 由于第三个符号 `>` 匹配失败，正则表达式引擎回溯，回溯会使 `.+` `减少（吐出）`一个字符，回溯后的匹配状况是 `.+` 匹配 `EM>first</EM> tes`。
6. 正则表达式引擎使用符号 `>` 匹配 `t`，结果依然不匹配。
7. 如果重复 `5`、`6` 两步，直到 `.+` 匹配 `EM>first</EM` 时，正则表达式使用符号 `>` 匹配 `> test`，匹配成功。
8. 正则表达式引擎报告 `<EM>first</EM>` 就是匹配上的文本。

## 可选性（optional）

我们都知道量词 `?` 可以使前一个正则表达式字符是可选的，如：`colou?r` 可以匹配 `colour` 和 `color`。当然你也可以使用括号 `()` 将一些字符或规则标识为可选的，如：Nov(ember)? 将会匹配 `Nov` 和 `November`，当然你也可以使用 `{0,1}` 拉替代 `?`，他们是等价的。

默认情况下 `?` 也是 `贪性匹配` 的，即：他会优先尝试匹配该字符存在的情况，如果匹配失败，则尝试匹配该字符不存在的情况。例如：
我们用 `Feb 23(rd)?` 表达式匹配 `Today is Feb 23rd, 2003` 文本，匹配结果是 `Feb 23rd` 而不是 `Feb 23`。

如果是：`Feb 23(rd)??` 呢？结果却是 `Feb 23`，是不是很奇妙，下面我们将会详细解答惰性匹配的原理。

## 惰性匹配（laziness）

惰性模式就是一旦匹配到合适的就结束，不在继续匹配下去了，在重复量词后面添加问号 `?` 即可形成惰性匹配。惰性匹配会尽可能少的匹配字符，但是必须要满足整个匹配模式。

> 惰性匹配就是匹配尽可能 `少` 的内容。

| 量词 |  匹配规则  |
|:----:|:----:|
| ??   | 匹配出现 0 次或 1 次，优先匹配 0 次 |
| +?   | 匹配出现 1 次或多次，尽可能重复少的次数，不过最少次数是 1 |
| *?   | 匹配出现 0 次或 1 次或多次，尽可能重复少的次数 |
| {n}? | 匹配刚好出现 n 次 |  /a{5}/.test('aaaab'); | 
| {n,m}?   | 匹配最少出现 n 次最多出现 m 次，尽可能重复少的次数，不过最少次数是 n |
| {n,}?    | 匹配最少出现 n 次，尽可能重复少的次数，不过最少次数是 n |

`<.+?>` 匹配字符串 `This is a <EM>first</EM> test` 的过程：

1. 第一个符号为 `<`，所以它将会匹配到字符串中的第一个 `<` 字符。
2. 第二个符号为 `.`，匹配任意字符（除了换行），使用 `+?` 重复匹配，因为是惰性匹配，所以 `+` 会尽可能少的匹配（最少一次），第一次 `.+` 匹配了 `E`。
3. 正则表达式引擎开始对下一个正则表达式符号 `>` 进行匹配，剩下的字符串 `M>first</EM> test` 的第一个字符为 `M`，于是匹配失败。
4. 由于第三个符号 `>` 匹配失败，正则表达式引擎回溯，回溯会使 `.+` `扩大（吞入）`一个字符，而不是贪性匹配的`减少`一个字符，回溯后的匹配状况是 `.+` 匹配 `EM`。
5. 正则表达式引擎开始对下一个正则表达式符号 `>` 进行匹配，剩下的字符串 `>first</EM> test` 的第一个字符为 `>`，于是匹配成功。
6. 正则表达式引擎报告 `<EM>` 就是匹配上的文本。

## 总结
贪性匹配，正则引擎会一直匹配到字符串最后；当匹配为 `false` 时，就回溯以找到倒数第一个匹配位置，返回匹配结果。 

惰性匹配，正则引擎会匹配到符合 `pattern` 的末尾位置那个字符，然后再往后走一步，发现匹配为 `false` 时，就回溯以找到最近一个匹配为 `true` 的位置，返回匹配结果。

改善 `贪性`、`惰性`，减少回溯次数，能够有利于正则表达式的执行效率，写出更好的正则表达式。

如我们可以使用 `<[^>]+>` 来取代 `<.+?>` 和 `<.+>`，这样回溯次数就降到了 `0` 次，当然，效率和耗时都是最佳的。

## 参考连接

[Optional Items](http://www.regular-expressions.info/optional.html)
[Repetition with Star and Plus](http://www.regular-expressions.info/repeat.html)
